"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeRemote = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const errors_1 = require("./errors");
const fetch_1 = require("./fetch");
async function invokeRemote(remoteKey, options) {
    const { path, ...fetchOptions } = options;
    if (!remoteKey) {
        throw new Error('Missing remote key provided to invokeRemote');
    }
    if (!path) {
        throw new Error('Missing or empty path provided to invokeRemote');
    }
    let response;
    if (global.__forge_fetch__) {
        response = await global.__forge_fetch__({
            type: 'frc',
            remote: remoteKey
        }, path, fetchOptions);
    }
    else {
        const url = (0, fetch_1.createRemoteUrlWithPath)('https://atl-paas.net', path);
        url.searchParams.set('remoteKey', remoteKey);
        const init = (0, fetch_1.addMagicAgent)(fetchOptions, 'FORGE_REMOTE_COMPUTE_REQUEST');
        response = await (0, node_fetch_1.default)(url, init);
    }
    handleResponseErrors(response, remoteKey);
    return response;
}
exports.invokeRemote = invokeRemote;
function handleResponseErrors(response, remoteKey) {
    const forgeProxyError = (0, fetch_1.getForgeProxyError)(response);
    if (forgeProxyError === 'INVALID_REMOTE') {
        throw new errors_1.InvalidRemoteError(`Invalid remote key provided: "${remoteKey}"`, remoteKey);
    }
    (0, fetch_1.handleProxyResponseErrors)(response);
}
